## 3. Задача: Поэлементное Применение Функции к Кортежу

`std::tuple` (кортеж) — это мощный инструмент для хранения гетерогенных данных. Однако, в отличие от `std::vector`, по нему нельзя просто так пройтись в цикле `for`, поскольку типы его элементов различны и известны только на этапе компиляции.

Это задание — спроектировать и реализовать функцию, которая "обходит" `std::tuple` на этапе компиляции, применяя заданную функцию (лямбду) к каждому элементу.

**Задача:** Написать шаблонную функцию `for_each_in_tuple(tuple, function)`, которая использует выражения свёртки (fold expressions) C++17 для применения function к каждому элементу `tuple`.

### **Техническое Задание (ТЗ)**

**1. Основной интерфейс (C++):**

Функция должна принимать `std::tuple` (по универсальной ссылке) и вызываемый объект.

```cpp
#include <tuple>
#include <utility> // для std::index_sequence

// Интерфейс, который должен быть реализован
template <typename Tuple, typename Func>
void for_each_in_tuple(Tuple&& t, Func&& f) {
    // ... реализация ...
}
```

**2. Ключевые требования к кешу:**

- **Использование C++17:** Обязательно использование выражений свёртки (`fold expressions`).
- **Универсальность:** Функция должна корректно работать с `const` и `non-const` кортежами, а также с `lvalue` и `rvalue` (используя `std::forward`).
- **Порядок вызова:** Функция должна применяться к элементам последовательно (от 0-го к последнему).

### **Архитектура и алгоритм**

Прямой обход кортежа невозможен, но мы можем обойти _индексы_ кортежа.

1. **`std::index_sequence`:** Мы используем `std::make_index_sequence<N>` для генерации последовательности индексов `std::index_sequence<0, 1, 2, ..., N-1>`, где `N` — размер кортежа (`std::tuple_size_v`).
2. **Вспомогательная функция:** Создается `for_each_in_tuple_impl`, которая принимает эту последовательность индексов как шаблонный пакет параметров (`size_t... Is`).
3. **Выражение свёртки (Fold Expression):** Внутри `_impl` мы используем оператор "запятая" (`,`) для свёртки пакета.
    - `(... , f(std::get<Is>(t)))`
    - Это выражение раскрывается в: `( f(std::get<0>(t)), f(std::get<1>(t)), f(std::get<2>(t)), ... )`
    - Оператор "запятая" гарантирует последовательное выполнение слева направо.

```
graph TD
    A[for_each_in_tuple(tuple, func)] --> B{std::tuple_size_v<Tuple>};
    B --> C[std::make_index_sequence<N>];
    C --> D[Вызов _impl(tuple, func, std::index_sequence<0, 1, ...N-1>)];
    D --> E[Раскрытие Fold Expression];
    E --> F[... , (f(std::get<Is>(t)))];
    F --> G[Выполнение: f(get<0>), f(get<1>), f(get<2>)];
```

### **Пример интерфейса (C++)**

```cpp
#include <tuple>
#include <utility> // для std::index_sequence, std::forward
#include <cstddef> // для size_t

// 1. Вспомогательная функция, принимающая индексы
template <typename Tuple, typename Func, std::size_t... Is>
void for_each_in_tuple_impl(Tuple&& t, Func&& f, std::index_sequence<Is...>) {
    // Выражение свёртки C++17
    ( (void)std::forward<Func>(f)(std::get<Is>(std::forward<Tuple>(t))), ... );
    // (void) используется для подавления предупреждений о неиспользуемом результате
}

// 2. Основной интерфейс
template <typename Tuple, typename Func>
void for_each_in_tuple(Tuple&& t, Func&& f) {
    constexpr size_t N = std::tuple_size_v<std::decay_t<Tuple>>;
    for_each_in_tuple_impl(
        std::forward<Tuple>(t),
        std::forward<Func>(f),
        std::make_index_sequence<N>{}
    );
}
```

### Этапы выполнения

1. Реализуйте вспомогательную функцию `for_each_in_tuple_impl`.
2. Внутри нее используйте выражение свёртки C++17 с оператором "запятая" и `std::get<Is>`.
3. Реализуйте основную функцию `for_each_in_tuple`, которая вычисляет размер кортежа и генерирует `std::index_sequence`.
4. Напишите тесты (`gtest`), которые передают лямбду, модифицирующую внешнюю переменную (например, счетчик или сумму), и проверяют результат.


### Дополнительное Задание (для заинтересованных)

**Реализовать `tuple_transform`**

**Задача:** Реализовать функцию `tuple_transform(tuple, func)`, которая возвращает **новый** кортеж, где каждый элемент является результатом применения `func` к соответствующему элементу исходного `tuple`.

**Сложность:** Требует понимания, как `std::make_tuple` работает с выражениями свёртки.
