## 2. Задача: Компиляция Вектора Типов (GetTypeAtIndex)

При работе с вариативными шаблонами (variadic templates) часто возникает необходимость рассматривать пакет параметров (`Ts...`) не как единое целое, а как коллекцию, из которой можно получить элемент по индексу.
Это задание — спроектировать и реализовать "список типов" (TypeList) и метафункцию для извлечения типа по индексу на этапе компиляции.

**Задача:** Написать метафункцию `GetTypeAtIndex<N, List>`, которая возвращает $N$-й тип из `TypeList<Ts...>`, где `List` — это `TypeList`.

### **Техническое Задание (ТЗ)**

**1. Основной интерфейс (C++):**

Метафункция должна предоставлять вложенный `::type`, который является искомым типом.

```cpp
// Структура для хранения списка типов
template <typename... Ts>
struct TypeList {};

// Интерфейс, который должен быть реализован
template <size_t N, typename List>
struct GetTypeAtIndex;

// Пример использования:
// using MyList = TypeList<int, float, double>;
// using T = typename GetTypeAtIndex<1, MyList>::type; // T должен быть float
```

**2. Ключевые требования к метафункции:**

- **Работа на этапе компиляции:** Вся логика должна выполняться компилятором.
- **Извлечение по индексу:** `GetTypeAtIndex<0, TypeList<A, B, C>>::type` должен быть `A`.
- **Обработка ошибок:** (Опционально, но желательно) Если индекс выходит за границы, компиляция должна завершиться с ошибкой (это стандартное поведение для рекурсивной реализации).

### **Архитектура и алгоритм**

Классическая реализация этой метафункции использует **рекурсивную частичную специализацию шаблонов**.

1. **`TypeList`:** Простая структура-заглушка, хранящая пакет типов.
2. **Общий шаблон:** `template <size_t N, typename List> struct GetTypeAtIndex;` объявляется, но не определяется.
3. **Базовый случай (N=0):** Создается частичная специализация для `N=0`.
    - `template <typename H, typename... Ts> struct GetTypeAtIndex<0, TypeList<H, Ts...>>`
    - Она "отделяет" первый тип (`H`) от остальных (`Ts...`).
    - Она определяет `using type = H;`.
4. **Рекурсивный случай (N > 0):** Создается частичная специализация для `N`.
    - `template <size_t N, typename H, typename... Ts> struct GetTypeAtIndex<N, TypeList<H, Ts...>>`
    - Она также отделяет `H` от `Ts...`.
    - Она рекурсивно ищет тип в "хвосте" списка (`TypeList<Ts...>`), уменьшая индекс: `using type = typename GetTypeAtIndex<N - 1, TypeList<Ts...>>::type;`.

### **Пример интерфейса (C++)**

```cpp
#include <cstddef> // для size_t

template <typename... Ts>
struct TypeList {};

// 1. Общее объявление
template <size_t N, typename List>
struct GetTypeAtIndex;

// 2. Базовый случай рекурсии (N = 0)
template <typename H, typename... Ts>
struct GetTypeAtIndex<0, TypeList<H, Ts...>> {
    using type = H;
};

// 3. Рекурсивный шаг (N > 0)
template <size_t N, typename H, typename... Ts>
struct GetTypeAtIndex<N, TypeList<H, Ts...>> {
    using type = typename GetTypeAtIndex<N - 1, TypeList<Ts...>>::type;
};
```

### Этапы выполнения

1. Реализуйте структуру `TypeList`.
2. Объявите общий шаблон `GetTypeAtIndex`.
3. Реализуйте частичную специализацию для базового случая (`N=0`).
4. Реализуйте частичную специализацию для рекурсивного шага (`N > 0`).
5. Напишите тесты (`static_assert` или `gtest`), проверяющие извлечение типов по разным индексам.

### Дополнительное Задание (для заинтересованных)

**Реализовать метафункцию `RemoveAt<N, List>`**

**Задача:** Реализовать метафункцию, которая возвращает новый `TypeList`, идентичный `List`, но без $N$-го элемента.
**Сложность:** Требует объединения (конкатенации) списков типов. Вам, вероятно, понадобится сначала реализовать `Concat<List1, List2>`.
